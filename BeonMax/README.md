<b>HomeWork 1</b>

1. Запросить имя пользователя. Вывести Hello, [имя пользователя].</br>
2. Запросить у пользователя два целых числа и сохранить в двух переменных. Вывести значения.
Обменять значения переменных: например, если в переменной x было записано число 3, а в y число 5, сделать так, чтобы в y стало 3, а в x стало 5. Вывести значения после обмена.</br>
3. Запросить у пользователя целое число. Вывести количество цифр числа. Например, в числе 156 - 3 цифры.</br>
#

<b>HomeWork 2</b>

Запросить у пользователя длины трёх сторон треугольника. Длины могут быть представлены дробными значениями. После получения длин сторон - использовать формулу Герона для вычисления площади треугольника. Чтобы жизнь не казалась мёдом, найдите формулу самостоятельно. После вычисления площади - вывести результат на консоль.
#

<b>HomeWork 3</b>

Запросить у пользователя: фамилию, имя, возраст, вес, рост. Рассчитать ИМТ (индекс массы тела) по формуле ИМТ = вес (кг) / (рост (м) * рост (м)). Сформировать единую строку, в следующем формате:</br>
Your profile:</br>
Full Name: фамилия, имя</br>
Age: рост</br>
Weight: вес</br>
Height: рост</br>
Body Mass Index: ИМТ</br>
Вывести сформированную строку на консоль.
#

<b>HomeWork 4</b>

Запросить у пользователя два целочисленных значения и найти максимальное.
#

<b>HomeWork 5</b>

Числа Фибоначчи описываются следующей последовательностью: 1, 1, 2, 3, 5, 8, 13, 21… Первые два числа - единицы. Все последующие числа вычисляются как сумма двух предыдущих. Задание: запросить у пользователя кол-во чисел Фибоначчи, которое он хотел бы сгенерировать (вычислить), и, собственно, произвести генерацию (вычисление). В процессе генерации записывать числа в массив. После генерации вывести вычисленные числа.
#

<b>HomeWork 6</b>

Запросить у пользователя не более 10 целых положительных чисел. Пользователь может прекратить приём чисел, введя 0. После прекращения приёма целых чисел (это происходит в случае если было введено 10 чисел, либо пользователь ввёл 0, чтобы не вводить все 10) подсчитать среднее значение целых положительных чисел кратных трём и вывести на консоль.
#

<b>HomeWork 7</b>

Факториалом числа является произведение этого числа на все предшествующие этому числу числа (кроме 0). Факториал в математике записывается через восклицательный знак. Например 5! = 5*4*3*2*1 = 120. Особые случаи: 0! = 1. 1! = 1.</br>
Задание: запросить у пользователя число, факториал которого необходимо вычислить и произвести вычисление. Затем вывести результат вычисления. Восклицательный знак запрашивать не надо, кроме того, в C# такой операции нет. Для вычисления факториала надо производить перемножение.
#

<b>HomeWork 8</b>

Предположим, что логин\пароль для входа в систему: johnsilver\qwerty. Запросить у пользователя логин и пароль. Дать пользователю только три попытки для ввода корректной пары логин\пароль. Если пользователь произвёл корректный ввод, вывести на консоль: "Enter the System" и прекратить запрос логина\пароля. Если пользователь ошибся трижды - вывести "The number of available tries have been exceeded" и прекратить запрос пары логин\пароль.
#

<b>HomeWork 9</b>

Написать функцию, которая принимает на вход строку - римское число, а возвращает это число в арабском виде. Например, если передаём "XV" - должна вернуть 15, если передаём "IV" - должна вернуть 4.</br>

Вот список римских символов и их отображение на арабские числа:</br>
I - 1</br>
V - 5</br>
X - 10</br>
L - 50</br>
C - 100</br>
D - 500</br>
M - 1000</br>

Варианты типа IIIV = 5-3 = 2 мы не рассматриваем. Хотя Римляне и пользовались иногда такими видами записей, но есть разная информация о приемлимости оных. В нашем ДЗ такие варианты мы не рассматриваем. Вот выдержка из wiki:</br>
"Необходимо отметить, что другие способы «вычитания» недопустимы; так, число 99 должно быть записано как XCIX, но не как IC."</br>

Подсказка. Для решения надо реализовать два правила:</br>
Правила записи чисел римскими цифрами:</br>
- если большая цифра стоит перед меньшей, то они складываются (принцип сложения)</br>
- если меньшая цифра стоит перед большей, то меньшая вычитается из большей (принцип вычитания).</br>

Защиту от некорректного ввода реализовать по вашему желанию (можно не делать, но для тренировки всегда полезно).
#

<b>HomeWork 10</b>

Добавить перегрузку, которая принимает длины двух смежных сторон (double) и величину угла между ними. Величину угла принимать как int.
Метод должен рассчитывать площадь по формуле: 0.5 * ab * ac * sin(alpha)

#

<b>HomeWork 11</b>

Разработать класс представляющий комплексное число. Класс должен содержать два свойства для представления вещественной (double) и мнимой части (double). Сделать так, чтобы создать экземпляр класса без передачи соответствующих аргументов было невозможно.</br>
Создать два метода, реализующих сложение и вычитание двух комплексных чисел. Чтобы сложить два комплексных числа необходимо по отдельности сложить их вещественные и мнимые части.</br>
То есть, предположим, что мы имеет два комплексных числа. У первого вещественная часть равна 1, мнимая 2. У второго вещественная часть равна 3, мнимая 1. Результатам будет комплексное число, где вещественная часть равна 1 + 3 = 4, а мнимая равна 2 + 1 = 3.</br>
Операция вычитания работает по тому же принципу, что и сложение (ну, только вычитание).</br>
API спроектировать таким образом, чтобы клиентский код мог написать следующий код:</br>

Complex c1 = new Complex(1, 1);</br>
Complex c2 = new Complex(1, 2);</br>

Complex result = c1.Plus(c2);</br>

#

<b>HomeWork 12</b>

Разработать игру "угадай число".</br>

<b>Смысл игры</b></br>

Один из игроков загадывает число от 0 до 100 (по умолчанию), а второй пытается угадать за лимитированное число попыток (5 по умолчанию). Когда второй игрок делает предположение о загаданном числе, первый игрок сообщает о том угадано ли число, меньше ли оно загаданного, или больше. Если угадано - игра завершена. Если меньше или больше загаданного, то второй игрок сужает область поиска и продолжает пытаться угадывать. Так происходит до тех пор пока либо число не угадано, либо исчерпано кол-во попыток.</br>

Загадывать может как человек, так и машина. Соответственно и угадывать может как человек, так и машина. Это значит, что надо реализовать два режима игры: когда загадывает машина и когда загадывает человек.</br>

Если загадывает человек, а угадывает машина, то нужно сделать так, чтобы машина пыталась угадать число, используя алгоритм бинарного поиска.</br>

Пример бинарного поиска загаданного числа:</br>
загадано число 18, при условии, что число загадывалось в диапазоне от 0 до 100. Игрок каждый раз берёт середину, т.е. на первой попытке предполагает число 50. Первый игрок говорит, что загаданное число меньше. Значит число лежит между 0 и 50. Тогда второй игрок снова делит диапазон на 2 и предполагает 25. Первый игрок говорит, что загаданное число меньше. Значит число между 0 и 25. Тогда второй игрок снова делит диапазон на 2 и предполагает 12 (дробную часть мы просто срезаем). Первый игрок говорит, что загаданное число больше. Значит число лежит в диапазоне между 12 и 25. Второй игрок делить диапазон на два и предполагает 18. Первый игрок говорит, что число угадано. Игра завершена.</br>

На каждой попытке , благодаря так стратегии, диапазон поиска сужается в два раза. Это и есть суть бинарного поиска. В конце игры выводится информация о том достигнута ли победа или нет. Конечно же, будет необходимо реализовать диалог между игроками.
